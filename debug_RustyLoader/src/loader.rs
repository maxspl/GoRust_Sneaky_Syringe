use core::{ffi::c_void, ptr::null_mut, slice::from_raw_parts, mem::{transmute, size_of}, arch::asm, ptr::read, ptr::write};
use ntapi::{ntpebteb::PEB, ntldr::LDR_DATA_TABLE_ENTRY, winapi::um::winnt::{IMAGE_DATA_DIRECTORY}};
use windows_sys::{
    core::PCSTR,
    Win32::{
        Foundation::{BOOL, FARPROC, HANDLE, HINSTANCE},
        System::{
            Diagnostics::{Debug::{
                IMAGE_NT_HEADERS64, IMAGE_NT_HEADERS32,
                IMAGE_SECTION_HEADER, IMAGE_DIRECTORY_ENTRY_EXPORT, IMAGE_DIRECTORY_ENTRY_BASERELOC, IMAGE_DIRECTORY_ENTRY_IMPORT,
            }},
            Memory::{
                MEM_COMMIT, MEM_RESERVE,
                PAGE_EXECUTE_READWRITE, PAGE_PROTECTION_FLAGS,
                VIRTUAL_ALLOCATION_TYPE,
            },
            SystemServices::{
                DLL_PROCESS_ATTACH, IMAGE_EXPORT_DIRECTORY, IMAGE_BASE_RELOCATION, IMAGE_REL_BASED_HIGHLOW, IMAGE_REL_BASED_DIR64, IMAGE_IMPORT_DESCRIPTOR, IMAGE_ORDINAL_FLAG64, IMAGE_ORDINAL_FLAG32, IMAGE_IMPORT_BY_NAME, IMAGE_RELOCATION,
            }, WindowsProgramming::IMAGE_THUNK_DATA64,WindowsProgramming::IMAGE_THUNK_DATA32,
        },
    },
};


pub fn hello_from_lib(){
    println!("Hello from lib");
    
    return
}
use std::ffi::CStr;
use std::os::raw::c_char;



#[repr(C)]
pub struct IMAGE_DOS_HEADER {
    pub e_magic: u16,    // Magic number
    pub e_cblp: u16,     // Bytes on last page of file
    pub e_cp: u16,       // Pages in file
    pub e_crlc: u16,     // Relocations
    pub e_cparhdr: u16,  // Size of header in paragraphs
    pub e_minalloc: u16, // Minimum extra paragraphs needed
    pub e_maxalloc: u16, // Maximum extra paragraphs needed
    pub e_ss: u16,       // Initial (relative) SS value
    pub e_sp: u16,       // Initial SP value
    pub e_csum: u16,     // Checksum
    pub e_ip: u16,       // Initial IP value
    pub e_cs: u16,       // Initial (relative) CS value
    pub e_lfarlc: u16,   // File address of relocation table
    pub e_ovno: u16,     // Overlay number
    pub e_res: [u16; 4], // Reserved words
    pub e_oemid: u16,    // OEM identifier (for e_oeminfo)
    pub e_oeminfo: u16,  // OEM information; e_oemid specific
    pub e_res2: [u16; 10], // Reserved words
    pub e_lfanew: i32,   // File address of new exe header
}

pub fn dbj2_hash(buffer: &[u8]) -> u32 
{
    let mut hsh: u32 = 5381;
    let mut iter: usize = 0;
    let mut cur: u8;

    while iter < buffer.len() 
    {
        cur = buffer[iter];

        if cur == 0 
        {
            iter += 1;
            continue;
        }

        if cur >= ('a' as u8) 
        {
            cur -= 0x20;
        }

        hsh = ((hsh << 5).wrapping_add(hsh)) + cur as u32;
        iter += 1;
    }

    return hsh;
}

pub unsafe fn grab_str_from_ptr(ptr: usize) -> &'static [u8]{
    // Take a slice of u8 from pointer and increments it with i
    // For each element j of the slice, check if last element is null byte
    // If null byte is found, return slice without null byte 

    let mut i:usize = 2;
    let mut exit=false;
    loop {
        let string_slice_without_null_char = from_raw_parts(ptr as *const u8, i-1);
        let string_slice = from_raw_parts(ptr as *const u8, i);

        for j in 0..=i-1{
            if string_slice[j] == 0 {
                return  string_slice_without_null_char
            }
        }
        i+=1;
    }

}
#[no_mangle]
pub unsafe extern "system" fn ReflectiveLoader(p: *mut c_void) ->   usize {

    // STEP 1: process the kernels exports for the functions our loader needs...

    // modules hashes generated by dbj2_hash
    let KERNEL32_HASH: u32 = 0x6ddb9555;
    let NTDLL_HASH: u32 = 0x1edab0ed;
    let LOAD_LIBRARY_A_HASH: u32 = 0xb7072fdb;
    let GET_PROC_ADDRESS_HASH: u32 = 0xdecfc1bf;
    let VIRTUAL_ALLOC_HASH: u32 = 0x97bc257;
    let FLUSH_INSTRUCTION_CACHE_HASH: u32 = 0x6269b87f;


    // Create function pointers
    #[allow(non_camel_case_types)]
    type fnLoadLibraryA = unsafe extern "system" fn(lplibfilename: PCSTR) -> HINSTANCE;
    let mut LoadLibraryA = transmute::<_, fnLoadLibraryA>(0x00000 as  usize); //dummy assignation

    #[allow(non_camel_case_types)]
    type fnGetProcAddress = unsafe extern "system" fn(hmodule: HINSTANCE, lpprocname: PCSTR) -> FARPROC;
    let mut GetProcAddress = transmute::<_, fnGetProcAddress>(0x00000 as  usize); //dummy assignation

    #[allow(non_camel_case_types)]
    type fnFlushInstructionCache = unsafe extern "system" fn(hprocess: HANDLE, lpbaseaddress: *const c_void, dwsize: usize) -> BOOL;
    let mut FlushInstructionCache = transmute::<_, fnFlushInstructionCache>(0x00000 as  usize); //dummy assignation

    #[allow(non_camel_case_types)]
    type fnVirtualAlloc = unsafe extern "system" fn(lpaddress: *const c_void, dwsize: usize, flallocationtype: VIRTUAL_ALLOCATION_TYPE, flprotect: PAGE_PROTECTION_FLAGS) -> *mut c_void;
    let mut VirtualAlloc = transmute::<_, fnVirtualAlloc>(0x00000 as  usize); //dummy assignation


    let var1 = 2;
    let var2 = 3;
    let loaded_module_base = p as *mut c_void;
    let dos_header: *mut IMAGE_DOS_HEADER = loaded_module_base as *mut IMAGE_DOS_HEADER;
    // unsafe {
    let e_magic = (*dos_header).e_magic;
    println!("e_magic : 0x{:x}",e_magic);
    let peb: *mut PEB = get_peb();
    println!("peb : {:?}",(*peb).Ldr);
    let pLdr: *mut ntapi::ntpsapi::PEB_LDR_DATA = (*peb).Ldr;
    println!("pLdr.Length : {:?}",(*pLdr).Length);
    //Flink contains a pointer to next entry
    let mut module_list: *mut ntapi::ntldr::LDR_DATA_TABLE_ENTRY = (*pLdr).InLoadOrderModuleList.Flink as *mut LDR_DATA_TABLE_ENTRY;// get the first entry of the InMemoryOrder module list
    let mut current_module_list: *mut LDR_DATA_TABLE_ENTRY = module_list;
    let mut dll_found_count = 0;
    loop {
        let pBuffer: *mut u16 = (*current_module_list).BaseDllName.Buffer;
        let module_length: usize = (*current_module_list).BaseDllName.Length  as usize ;  // we divide by 2 because each character is 2 bytes

        let dll_name_slice = from_raw_parts(pBuffer as *const u8, module_length);
        let module_hash: u32 = dbj2_hash(dll_name_slice);

        if module_hash == KERNEL32_HASH {
            // incremet counter to stop when both dll found
            dll_found_count += 1;
            //print module TO COMMENT
            match std::str::from_utf8(dll_name_slice) {
                Ok(v) => {
                    let dll_name_string = v.to_string();
                    println!("dll name :{}. Dll hash (ror13) : 0x{:x}", dll_name_string,module_hash);

                },
                Err(e) => panic!("Invalid UTF-8 sequence: {}", e),
            }
            println!("kernel32 hash found"); //TO COMMENT

            // get this modules base address
            let module_base_address: *mut  usize = (*current_module_list).DllBase as *mut usize;
            println!("module base : {:?}",module_base_address); //TO COMMENT

            // get the VA of the modules NT Header
            let module_dos_headers: *mut IMAGE_DOS_HEADER = module_base_address as *mut IMAGE_DOS_HEADER;
            let module_nt_headers_ptr = module_base_address as usize + (*module_dos_headers).e_lfanew as  usize;
            println!("module_nt_headers_ptr {:x}",module_nt_headers_ptr);

            // module_export_dir 
            // module_export_dir 
            #[cfg(target_pointer_width = "32")]
            let module_nt_headers: *mut IMAGE_NT_HEADERS32 = module_nt_headers_ptr as *mut IMAGE_NT_HEADERS32; //32bits_spec

            #[cfg(target_pointer_width = "64")]
            let module_nt_headers: *mut IMAGE_NT_HEADERS64 = module_nt_headers_ptr as *mut IMAGE_NT_HEADERS64; //64bits_spec - line add
            
            let module_export_dir =  (*module_nt_headers).OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT as usize];

            // get the VA of the export directory
            let module_image_data_directory:  usize = module_base_address as  usize + module_export_dir.VirtualAddress as usize;
            let module_image_data_directory2:  usize =  module_export_dir.VirtualAddress as usize; //32bits_spec - line mode
            println!("MSP module_image_data_directory {:x}",module_image_data_directory2);
            
            // get the VA for the array of name pointers
            let module_image_export_directory : *mut IMAGE_EXPORT_DIRECTORY = module_image_data_directory as *mut IMAGE_EXPORT_DIRECTORY;
            let mut module_AddressOfNames: *const usize = (module_base_address as usize + (*module_image_export_directory).AddressOfNames as usize) as *const usize;
            
            // get the VA for the array of name ordinals
            let mut module_AddressOfOrdinals: *const u16 = (module_base_address as usize + (*module_image_export_directory).AddressOfNameOrdinals as usize) as *const u16;
            let mut counter = 0;
            // for i in 0..(*module_image_export_directory).NumberOfNames{
            //     let name_addr = (module_base_address as usize + names[i as usize] as usize) as *const i8;
            // }\
            let mut count = 0;
            
            while counter != 3{
                // get AddressOfNames value (RVA to function names array)
                let module_AddressOfNames_dereferenced: u32 = *(module_AddressOfNames as *const u32) ; //32bits_spec - line mode
                
                // get offset of AddressOfNames value
                let function_name_ptr = module_base_address as usize + module_AddressOfNames_dereferenced as usize;
                
                //get slice of u8 from each function name
                let mut function_name_slice = grab_str_from_ptr(function_name_ptr);
                
                // get hash value of the function name
                let function_name_hash: u32 = dbj2_hash(function_name_slice);
                
                if function_name_hash == GET_PROC_ADDRESS_HASH || function_name_hash == LOAD_LIBRARY_A_HASH || function_name_hash == VIRTUAL_ALLOC_HASH {
                    counter += 1;
                    match std::str::from_utf8(function_name_slice) {
                        Ok(v) => {
                            let dll_name_string = v.to_string();
                            println!("...function_name : {}. function_name_hash : {:x} ", dll_name_string, function_name_hash);
        
                        },
                        Err(e) => panic!("Invalid UTF-8 sequence: {}", e),
                    }
                    // get the VA for the array of addresses
                    let mut AddressOfFunctions: *const u32  = (module_base_address as usize + (*module_image_export_directory).AddressOfFunctions as usize) as *const u32;  //32bits_spec - line mode

                    // use this functions name ordinal as an index into the array of name pointers
                    let ordinal_value = *(module_AddressOfOrdinals as *const u16) as isize;
                    AddressOfFunctions = (AddressOfFunctions as *const u32).offset(ordinal_value) as *const u32;//32bits_spec - line mode





                    
                    #[cfg(target_pointer_width = "32")]
                    println!("......AddressOfFunctions deref : 0x{:x}", *(AddressOfFunctions as *const u32)); //32bits_spec - line add

                    #[cfg(target_pointer_width = "64")]
                    println!("......AddressOfFunctions deref : 0x{:x}", *(AddressOfFunctions as *const u32)); //64bits_spec - line add

                    // get function VA
                    #[cfg(target_pointer_width = "32")]
                    let AddressOfFunctions_VA = module_base_address  as  usize + *(AddressOfFunctions as *const u32) as usize; //32bits_spec - line add

                    #[cfg(target_pointer_width = "64")]
                    let AddressOfFunctions_VA = module_base_address  as  usize + *(AddressOfFunctions as *const u32) as usize; //64bits_spec - line add
                    
                    // store this functions VA
                    if function_name_hash == LOAD_LIBRARY_A_HASH {
                        //let LoadLibraryA = transmute::<_, fnLoadLibraryA>(AddressOfFunctions_VA);
                        //let LoadLibraryA: *mut fnLoadLibraryA = AddressOfFunctions_VA as *mut fnLoadLibraryA;
                        LoadLibraryA = transmute::<_, fnLoadLibraryA>(AddressOfFunctions_VA);
                    }
                    if function_name_hash == GET_PROC_ADDRESS_HASH {
                        //let GetProcAddress: *mut fnGetProcAddress = AddressOfFunctions_VA as *mut fnGetProcAddress;
                        GetProcAddress = transmute::<_, fnGetProcAddress>(AddressOfFunctions_VA);
                    }
                    
                    if function_name_hash == VIRTUAL_ALLOC_HASH {
                        //VirtualAlloc = AddressOfFunctions_VA as *mut fnVirtualAlloc;
                        VirtualAlloc = transmute::<_, fnVirtualAlloc>(AddressOfFunctions_VA);
                        //VirtualAlloc = Some(transmute::<_, fnVirtualAlloc>(AddressOfFunctions_VA));
                        

                    }
                    
                }

                
                // get the next exported function name
                // offset function offsets the pointer by the size of the type the pointer is pointing to
                // module_AddressOfNames = module_AddressOfNames.offset(1); //add dword
                module_AddressOfNames = (module_AddressOfNames as *const u16).offset(2) as *const usize; // add 2x u16 = DWORD
                
                // get the next exported function name ordinal
                module_AddressOfOrdinals = (module_AddressOfOrdinals as *const u16).offset(1) as *const u16; // add 1x u16 = WORD
                count += 1;
                
            }
            
        }
        else if  module_hash == NTDLL_HASH {
            // incremet counter to stop when both dll found
            dll_found_count += 1;
            //print module TO COMMENT
            println!("NTDLL hash found"); //TO COMMENT

            // get this modules base address
            let module_base_address: *mut  usize = (*current_module_list).DllBase as *mut usize;
            println!("module base : {:?}",module_base_address); //TO COMMENT

            // get the VA of the modules NT Header
            let module_dos_headers: *mut IMAGE_DOS_HEADER = module_base_address as *mut IMAGE_DOS_HEADER;
            let module_nt_headers_ptr = module_base_address as usize + (*module_dos_headers).e_lfanew as  usize;
            println!("module_nt_headers_ptr {:x}",module_nt_headers_ptr);

            // module_export_dir 
            #[cfg(target_pointer_width = "32")]
            let module_nt_headers: *mut IMAGE_NT_HEADERS32 = module_nt_headers_ptr as *mut IMAGE_NT_HEADERS32; //32bits_spec - line add

            #[cfg(target_pointer_width = "64")]
            let module_nt_headers: *mut IMAGE_NT_HEADERS64 = module_nt_headers_ptr as *mut IMAGE_NT_HEADERS64; //32bits_spec - line add

            let module_export_dir =  (*module_nt_headers).OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT as usize];

            // get the VA of the export directory
            let module_image_data_directory:  usize = module_base_address as  usize + module_export_dir.VirtualAddress as usize;
            let module_image_data_directory2:  usize =  module_export_dir.VirtualAddress as usize; //32bits_spec - line mode
            println!("MSP module_image_data_directory 0x{:x}",module_image_data_directory2);

            // get the VA for the array of name pointers
            let module_image_export_directory : *mut IMAGE_EXPORT_DIRECTORY = module_image_data_directory as *mut IMAGE_EXPORT_DIRECTORY;
            let mut module_AddressOfNames: *const usize = (module_base_address as usize + (*module_image_export_directory).AddressOfNames as usize) as *const usize;
            println!("MSP AddressOfNames 0x{:x}",(*module_image_export_directory).AddressOfNames);
            
            // get the VA for the array of name ordinals
            let mut module_AddressOfOrdinals: *const u16 = (module_base_address as usize + (*module_image_export_directory).AddressOfNameOrdinals as usize) as *const u16;
            let mut counter = 0;
            // for i in 0..(*module_image_export_directory).NumberOfNames{ 
            //     let name_addr = (module_base_address as usize + names[i as usize] as usize) as *const i8;
            // }\
            let mut count = 0;
            while counter != 1{
                // get AddressOfNames value (RVA to function names array)
                let module_AddressOfNames_dereferenced: u32 = *(module_AddressOfNames as *const u32) ; //32bits_spec - line mode
                //let module_AddressOfNames_dereferenced  = read(module_AddressOfNames as *mut usize);
                println!("module_AddressOfNames_dereferenced : {:x}",module_AddressOfNames_dereferenced);
                // loop {
                //     let a = 61;
                // }
                // get offset of AddressOfNames value
                let function_name_ptr = module_base_address as usize + module_AddressOfNames_dereferenced as usize;

                //get slice of u8 from each function name
                let mut function_name_slice = grab_str_from_ptr(function_name_ptr);

                // get hash value of the function name
                let function_name_hash: u32 = dbj2_hash(function_name_slice);

                if function_name_hash == FLUSH_INSTRUCTION_CACHE_HASH {
                    counter += 1;
                    match std::str::from_utf8(function_name_slice) {
                        Ok(v) => {
                            let dll_name_string = v.to_string();
                            println!("...function_name : {}. function_name_hash : {:x} ", dll_name_string, function_name_hash);
        
                        },
                        Err(e) => panic!("Invalid UTF-8 sequence: {}", e),
                    }
                    // get the VA for the array of addresses
                    let mut AddressOfFunctions: *const u32  = (module_base_address as usize + (*module_image_export_directory).AddressOfFunctions as usize) as *const u32; //32bits_spec - line mode

                    // use this functions name ordinal as an index into the array of name pointers
                    let ordinal_value = *(module_AddressOfOrdinals as *const u16) as isize;
                    AddressOfFunctions = (AddressOfFunctions as *const u32).offset(ordinal_value) as *const u32; //32bits_spec - line mode
                    println!("......AddressOfFunctions deref : 0x{:x}", *(AddressOfFunctions as *const u32)); //32bits_spec - line mode

                    // get function VA
                    let AddressOfFunctions_VA = module_base_address  as  usize + *(AddressOfFunctions as *const u32) as usize; //32bits_spec - line mode
                    // store this functions VA
                    if function_name_hash == FLUSH_INSTRUCTION_CACHE_HASH {
                        //let FlushInstructionCache: *mut fnFlushInstructionCache = AddressOfFunctions_VA as *mut fnFlushInstructionCache;
                        FlushInstructionCache = transmute::<_, fnFlushInstructionCache>(AddressOfFunctions_VA);
                    }
                }
                
                // get the next exported function name
                // offset function offsets the pointer by the size of the type the pointer is pointing to
                // module_AddressOfNames = module_AddressOfNames.offset(1); //add dword
                module_AddressOfNames = (module_AddressOfNames as *const u16).offset(2) as *const usize; // add 2x u16 = DWORD
                // get the next exported function name ordinal
                module_AddressOfOrdinals = (module_AddressOfOrdinals as *const u16).offset(1) as *const u16; // add 1x u16 = WORD
                count += 1;

            }

        }

        // move to the next entry
        current_module_list = (*current_module_list).InLoadOrderLinks.Flink as *mut ntapi::ntldr::LDR_DATA_TABLE_ENTRY;
        
        // stop when we're back at the start
        if current_module_list == module_list || dll_found_count == 2{
            break;
        }

    }
    // STEP 2: load our image into a new permanent location in memory...

    // get the VA of the NT Header for the PE to be loaded
    let loaded_module_DOS_Headers: *mut IMAGE_DOS_HEADER = loaded_module_base as *mut IMAGE_DOS_HEADER;
    let NT_Headers_address = loaded_module_base as usize + (*loaded_module_DOS_Headers).e_lfanew as usize;

    #[cfg(target_pointer_width = "32")]
    let loaded_module_NT_Headers: *mut IMAGE_NT_HEADERS32 = NT_Headers_address as *mut IMAGE_NT_HEADERS32; //32bits_spec - line add

    #[cfg(target_pointer_width = "64")]
    let loaded_module_NT_Headers: *mut IMAGE_NT_HEADERS64 = NT_Headers_address as *mut IMAGE_NT_HEADERS64; //64bits_spec - line add

    //println!("Magic {:x}",(*loaded_module_NT_Headers).OptionalHeader.Magic);
    
    println!("MSP ici");
	// allocate all the memory for the DLL to be loaded into. we can load at any address because we will  
	// relocate the image. Also zeros all memory and marks it as READ, WRITE and EXECUTE to avoid any problems.
    println!("SizeOfImage : {:x}",(*loaded_module_NT_Headers).OptionalHeader.SizeOfImage as usize);

    let mut new_base_address = VirtualAlloc(null_mut(), (*loaded_module_NT_Headers).OptionalHeader.SizeOfImage as usize, MEM_RESERVE|MEM_COMMIT, PAGE_EXECUTE_READWRITE );

    println!("new_base_address : {:?}",new_base_address);

    // step 2 : copy the headers
    let sizeofheaders = (*loaded_module_NT_Headers).OptionalHeader.SizeOfHeaders;
    let mut sizeofheaders_tmp = sizeofheaders;
    let mut loaded_module_base_tmp: *mut c_void = loaded_module_base;
    let mut new_base_address_tmp = new_base_address;

    while sizeofheaders_tmp > 0 {
        *(new_base_address_tmp as *mut u8) = *(loaded_module_base_tmp as *mut u8);
        sizeofheaders_tmp -= 1;
        loaded_module_base_tmp = (loaded_module_base_tmp as *mut u8).add(1) as *mut c_void;
        new_base_address_tmp = (new_base_address_tmp as *mut u8).add(1) as *mut c_void;
    }

    // step 3 : load all the sections

    // get the VA of the first section header
    let optional_headers_ptr = &(*loaded_module_NT_Headers).OptionalHeader as *const _ as usize; // get a pointer to OptionalHeader
    let mut first_section: *mut c_void = (optional_headers_ptr as  usize + (*loaded_module_NT_Headers).FileHeader.SizeOfOptionalHeader as usize) as *mut c_void;
    println!("first_section {:x}",*(first_section as *mut usize)); //32bits_spec - line mode

    // itterate through all sections, loading them into memory.
    let mut number_of_sections =  (*loaded_module_NT_Headers).FileHeader.NumberOfSections;

    while number_of_sections > 0 {

        // get the RVA of the section
        let mut section_headers: *mut IMAGE_SECTION_HEADER = first_section as *mut IMAGE_SECTION_HEADER; 
        let mut section_RVA = (*section_headers).VirtualAddress;
        println!("section_VA : 0x{:x}",section_RVA);

        // get the a ptr to new section VA
        let mut new_section_VA = (new_base_address as *mut u8).add(section_RVA as usize);
        println!("new_section_VA : 0x{:p}",new_section_VA);

        // get a ptr the section data
        let mut section_data = (loaded_module_base as usize + (*section_headers).PointerToRawData as usize) as *mut usize;
        println!("section_data : 0x{:x}",*(section_data as *mut usize)); //32bits_spec - line mode

        // get the section data size
        let mut section_data_size = (*section_headers).SizeOfRawData;
        
        // copy the data
        while section_data_size > 0 {
            *(new_section_VA as *mut u8) = *(section_data as *mut u8);
            section_data_size -= 1;
            new_section_VA = (new_section_VA as *mut u8).add(1);
            section_data = (section_data as *mut u8).add(1) as *mut usize;
        }

        // get IMAGE_SECTION_HEADER_size 
		let IMAGE_SECTION_HEADER_size = core::mem::size_of::<IMAGE_SECTION_HEADER>(); // usually 40 bytes
        // go to the next section headers 
        first_section = (first_section as *mut u8).add(40) as *mut c_void;
        
        number_of_sections -= 1;
    }


    // STEP 4: process our images import table...

    // get pointer to the address of the import directory
    let import_dir_addr: usize =  &(*loaded_module_NT_Headers).OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT as usize] as *const _ as usize;;
    println!("import_dir : {:x}",*(import_dir_addr as *mut usize)); //32bits_spec - line mode
    
    // We read the import dir RVA of the import dir from the raw (not loaded) dll header and we add it to the new base address
    let directory_import : *mut IMAGE_DATA_DIRECTORY = import_dir_addr as *mut IMAGE_DATA_DIRECTORY; 
    println!("import_dir : {:x}",(*directory_import).VirtualAddress);

    // address of first Import Dir entry
    let first_entry = (new_base_address as *mut u8).add((*directory_import).VirtualAddress as usize);
    println!("first_entry : {:x}",*(first_entry as *mut usize)); //32bits_spec - line mode
                
    // cast first import dir entry
    let mut first_entry_DESCRIPTOR : *mut IMAGE_IMPORT_DESCRIPTOR = first_entry as *mut IMAGE_IMPORT_DESCRIPTOR; 
    //let name_ptr = (new_base_address as *mut u8).add((*first_entry_DESCRIPTOR).Name as usize);;

    // contains ptr to the name of the first import dll
    // let mut name_ptr = (new_base_address as *mut u8).add((*first_entry_DESCRIPTOR).Name as usize);
    
    // let mut name_ptr_slice = grab_str_from_ptr(name_ptr as usize); //useless, to remove
    // println!("name_ptr_slice: {:?}",name_ptr_slice);
    while (*first_entry_DESCRIPTOR).Name != 0x0 {
        // contains ptr to the name of the imported dll
        let mut dll_name_ptr = (new_base_address as *mut u8).add((*first_entry_DESCRIPTOR).Name as usize);
    
        let mut dll_name_ptr_slice = grab_str_from_ptr(dll_name_ptr as usize); //useless, to remove
        println!("{:?}",dll_name_ptr_slice);

        // use LoadLibraryA to load the imported modules
        let dll_handle = LoadLibraryA(dll_name_ptr);
        println!("\n\ndll_handle {:x}",dll_handle);

        // get VA of the OriginalFirstThunk
        let mut OriginalFirstThunk = (new_base_address as *mut u8).add((*first_entry_DESCRIPTOR).Anonymous.OriginalFirstThunk as usize) as *mut usize;

        // get VA of the IAT (via first thunk not origionalfirstthunk)
        let mut FirstThunk_ptr: *mut usize = (new_base_address as *mut u8).add((*first_entry_DESCRIPTOR).FirstThunk as usize) as *mut usize;
        // println!("FirstThunk : {:x}",*(FirstThunk_ptr as *mut u32)); // print "Thunk value"
        // println!("FirstThunk : {:x}",(*first_entry_DESCRIPTOR).FirstThunk); // print "call via" value
        // println!("FirstThunk_ptr : {:p}",FirstThunk_ptr); // print "Thunk value"
        
        // iterate through all imported functions
        // thunk contains address of the IAT entry containing the function RVA
        while *(FirstThunk_ptr as *mut usize) != 0 { //32bits_spec - line mode

            // Just check if is working
            println!("\nFirstThunk : {:x}",*(FirstThunk_ptr as *mut usize)); // print "Thunk value" //32bits_spec - line mode
            // if *(FirstThunk_ptr as *mut u32) == 0x1ca20 {
            //     loop {
            //         let a = 61;
            //     }
            // }
            // sanity check OriginalFirstThunk as some compilers only import by FirstThunk. Will enter the if condition it import by ordinal
            #[cfg(target_pointer_width = "32")]
            let mut imagethunkdata : *mut IMAGE_THUNK_DATA32 = OriginalFirstThunk as * mut IMAGE_THUNK_DATA32; //32bits_spec - line add

            #[cfg(target_pointer_width = "64")]
            let mut imagethunkdata : *mut IMAGE_THUNK_DATA64 = OriginalFirstThunk as * mut IMAGE_THUNK_DATA64; //64bits_spec - line add

            println!("Ordinal : {:x}",(*imagethunkdata).u1.Ordinal);

            #[cfg(target_pointer_width = "32")]
            let IMAGE_ORDINAL_X = IMAGE_ORDINAL_FLAG32; //32bits_spec - line add

            #[cfg(target_pointer_width = "64")]
            let IMAGE_ORDINAL_X = IMAGE_ORDINAL_FLAG64; //64bits_spec - line add

            if !OriginalFirstThunk.is_null()  && (IMAGE_ORDINAL_X & (*imagethunkdata).u1.Ordinal) != 0{ //IMAGE_ORDINAL_FLAG64 equal to 0x8000000000000000  - 32bits_spec - line mode
                
                // get the VA of the modules NT Header
                let mut NT_Headers_address = loaded_module_base as usize + (*loaded_module_DOS_Headers).e_lfanew as usize;
            
                // get the address of the modules export directory entry
                #[cfg(target_pointer_width = "32")]
                let mut module_nt_headers: *mut IMAGE_NT_HEADERS32 = NT_Headers_address as *mut IMAGE_NT_HEADERS32; //32bits_spec - line add

                #[cfg(target_pointer_width = "64")]
                let mut module_nt_headers: *mut IMAGE_NT_HEADERS64 = NT_Headers_address as *mut IMAGE_NT_HEADERS64; //64bits_spec - line add

                let mut export_dir_entry_ptr =  (*module_nt_headers).OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT as usize];

                // get the VA of the export directory
                let mut export_dir_ptr:  usize = loaded_module_base as  usize + export_dir_entry_ptr.VirtualAddress as usize;

                // get the VA for the array of addresses
                let module_image_export_directory : *mut IMAGE_EXPORT_DIRECTORY = export_dir_ptr as *mut IMAGE_EXPORT_DIRECTORY;
                let mut array_address = loaded_module_base as usize  + ((*module_image_export_directory).AddressOfFunctions as usize) ;

                // use the import ordinal (- export ordinal base) as an index into the array of addresses

                //array_address = array_address + (IMAGE_ORDINAL((*imagethunkdata).u1.Ordinal) as usize - (*module_image_export_directory).Base as usize* 4) as usize;
                array_address = array_address + (  ((*imagethunkdata).u1.Ordinal & 0xFFF) as usize - (*module_image_export_directory).Base as usize* 4) as usize;
                // // patch in the address for this imported function
                *(FirstThunk_ptr as *mut usize)  = (loaded_module_base as  usize + *(array_address as *mut usize) as  usize) as  usize; //32bits_spec - line mode
            }
            else {
                // get the VA of this functions import by name struct
                let mut function_import_VA = (new_base_address as *mut u8).add((*(FirstThunk_ptr as *mut usize)) as usize); //32bits_spec - line mode
                println!("function_import_VA : {:p}",function_import_VA);

                // cast function_import_VA to IMAGE_IMPORT_BY_NAME struct
                let mut function_image_import_by_name : *mut IMAGE_IMPORT_BY_NAME = function_import_VA as *mut IMAGE_IMPORT_BY_NAME;

                // Get function name from IMAGE_IMPORT_BY_NAME
                let mut function_name = (*function_image_import_by_name).Name.as_ptr();
                println!("function_name : {:?}",function_name);

                // get function VA from GetProcAddress
                let mut function_VA:  usize = GetProcAddress(dll_handle, function_name).unwrap() as  _;
                println!("function_VA: {:x}", function_VA);

                // print ptr value
                println!("FirstThunk_ptr : {:p}", FirstThunk_ptr);

                // Patch the IAT
                *(FirstThunk_ptr as *mut usize) = function_VA  ;

                //Check if the IAT is patched and match the function_VA returned by GetProcAddress
                println!("FirstThunk patched : {:x}", *(FirstThunk_ptr as *mut usize)); //32bits_spec - line mode
            }
            // get next pointer
            FirstThunk_ptr = (FirstThunk_ptr as *mut usize).add(1) as *mut usize; //32bits_spec - line mode
        }
      

        // get the next entry
        first_entry_DESCRIPTOR = (first_entry_DESCRIPTOR as usize + size_of::<IMAGE_IMPORT_DESCRIPTOR>() as usize) as _;

        
    }


    // STEP 5: process all of our images relocations...

    // calculate the base address delta and perform relocations (even if we load at desired image base)
    println!("\nnew_base_address :{:p}",new_base_address);
    //println!("ImageBase :{:x}",(*loaded_module_NT_Headers).OptionalHeader.ImageBase); // MSP mod
    let base_address_delta = (new_base_address  as isize - (*loaded_module_NT_Headers).OptionalHeader.ImageBase as isize);

    // get the address of the relocation directory
    let mut relocation_directory =  (*loaded_module_NT_Headers).OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC as usize];
    println!("relocation_directory size :{:x}",relocation_directory.Size);

    // check if their are any relocations present
    if relocation_directory.Size != 0 {

        // get the first entry (IMAGE_BASE_RELOCATION)
        let relocation_directory_ptr = &mut relocation_directory as *mut _;
        let relocation_directory_IMAGE_DATA_DIRECTORY : *mut IMAGE_DATA_DIRECTORY = relocation_directory_ptr as *mut IMAGE_DATA_DIRECTORY; 
        let mut first_entry =  (new_base_address as *mut u8).add(((*relocation_directory_IMAGE_DATA_DIRECTORY).VirtualAddress) as usize);
        println!("first_entry  :{:x}",(*first_entry) as u64);

        // and we itterate through all entries...
        let mut first_entry_IMAGE_BASE_RELOC = first_entry as *mut IMAGE_BASE_RELOCATION;
        println!("first_entry_IMAGE_BASE_RELOC_size_block  :{:x}",(*first_entry_IMAGE_BASE_RELOC).SizeOfBlock);
        let mut first_entry_IMAGE_BASE_RELOC_size_block = (*first_entry_IMAGE_BASE_RELOC).SizeOfBlock;

        while (first_entry_IMAGE_BASE_RELOC_size_block != 0) {
            println!("\n\nfirst_entry  :{:x}",(*first_entry.add(1)) as u64);
            //println!("first_entry_IMAGE_BASE_RELOC_size_block  :{:x}",(*first_entry_IMAGE_BASE_RELOC).SizeOfBlock);
            
            // get the VA for this relocation block
            //let relocation_block_VA = new_base_address.add((*first_entry_IMAGE_BASE_RELOC).VirtualAddress as usize) as isize; 
            let relocation_block_VA = new_base_address  as usize +  (*first_entry_IMAGE_BASE_RELOC).VirtualAddress as usize;

            // get the number of entries in this relocation block
            let mut entries_number = ((*first_entry_IMAGE_BASE_RELOC).SizeOfBlock as usize - size_of::<IMAGE_BASE_RELOCATION>()) / size_of::<u16>() ;
            println!("Number of entries : {:x}",entries_number);

            // get the first entry in the current relocation block
            //let first_entry_in_block: *mut usize = first_entry.add(size_of::<IMAGE_BASE_RELOCATION>()) as *mut usize; // IMAGE_BASE_RELOCATION size should be 8
            let first_entry_in_block: *const u16 = first_entry.add(size_of::<IMAGE_BASE_RELOCATION>()) as *const u16; // IMAGE_BASE_RELOCATION size should be 8
            println!("first_entry_in_block : {:x}",(*first_entry_in_block) as usize); //32bits_spec - line mode
            
            // we itterate through all the entries in the current block...
            
            for i in 0..entries_number {

				// perform the relocation, skipping IMAGE_REL_BASED_ABSOLUTE as required.
				// we dont use a switch statement to avoid the compiler building a jump table
				// which would not be very position independent!
                let type_field: u32 = (first_entry_in_block.offset(i as isize).read() >> 12) as u32; //32bits_to_mode maybe
                let offset = first_entry_in_block.offset(i as isize).read() & 0xFFF;
                if type_field == IMAGE_REL_BASED_DIR64 || type_field == IMAGE_REL_BASED_HIGHLOW {
                    //*((relocation_block_VA + offset as isize) as *mut isize) += base_address_delta;
                    println!("\nnew_base_address : {:p}",new_base_address);
                    println!("VirtualAddress : {:x}",(*first_entry_IMAGE_BASE_RELOC).VirtualAddress);
                    println!("relocation_block_VA : {:x}",relocation_block_VA);
                    println!("offset : {:x}",offset);
                    println!("relocation_block_VA + offset : {:x}",relocation_block_VA + offset as usize);
                    println!("reloc block : {:x}",*((relocation_block_VA + (offset) as usize) as *mut u8) as u16);

                    // Read the original value at the final address
                    let ogaddress =  read((relocation_block_VA + offset as usize) as *const usize);
                    println!("ogaddress : {:x}",ogaddress);

                    // Calculate the fixed address of the relocation
                    let fixedaddress = (ogaddress as isize + base_address_delta as isize) as isize;
                    println!("fixedaddress : {:x}",fixedaddress);

                    //Write the fixed address to the final address
                    write((relocation_block_VA + offset as usize) as *mut usize, fixedaddress as usize);

                }
            }


            // get the next entry in the relocation directory
            first_entry = first_entry.add(first_entry_IMAGE_BASE_RELOC_size_block as usize);
            first_entry_IMAGE_BASE_RELOC = first_entry as *mut IMAGE_BASE_RELOCATION;
            first_entry_IMAGE_BASE_RELOC_size_block = (*first_entry_IMAGE_BASE_RELOC).SizeOfBlock;

        }
    }
    // STEP 6: call our images entry point

    // get the VA of our newly loaded DLL/EXE's entry point
    let entry_point = new_base_address as usize + (*loaded_module_NT_Headers).OptionalHeader.AddressOfEntryPoint as usize;
    //println!("\nEntry point : {:x}",*((entry_point + 3) as *mut usize) as u32);

    // We must flush the instruction cache to avoid stale code being used which was updated by our relocation processing.
    FlushInstructionCache(-1 as _, null_mut(), 0);

    // call our respective entry point, fudging our hInstance value
    #[allow(non_camel_case_types)]
    type fnDllMain = unsafe extern "system" fn(module: HINSTANCE, call_reason: u32, reserved: *mut c_void) -> BOOL;

    #[allow(non_snake_case)]
    let DllMain = transmute::<_, fnDllMain>(entry_point);

    DllMain(new_base_address as _, DLL_PROCESS_ATTACH, loaded_module_base as _);

    // STEP 8: return our new entry point address so whatever called us can call DllMain() if needed.
    return entry_point;
    // loop {
    //     let a = 61;
    // }
    // }
    
}

// #[link_section = ".text"]
// /// Get a pointer to the Thread Environment Block (TEB)
// pub unsafe fn get_teb() -> *mut ntapi::ntpebteb::TEB 
// {
//     let teb: *mut ntapi::ntpebteb::TEB;
//     asm!("mov {teb}, gs:[0x30]", teb = out(reg) teb);
//     teb
// }

// #[link_section = ".text"]
// /// Get a pointer to the Process Environment Block (PEB)
// pub unsafe fn get_peb() -> *mut PEB 
// {
//     let teb = get_teb();
//     let peb = (*teb).ProcessEnvironmentBlock;
//     peb
// }
#[link_section = ".text"]
/// Get a pointer to the Thread Environment Block (TEB)
#[cfg(target_pointer_width = "64")]
pub unsafe fn get_teb() -> *mut ntapi::ntpebteb::TEB 
{
    let teb: *mut ntapi::ntpebteb::TEB;
    asm!("mov {teb}, gs:[0x30]", teb = out(reg) teb);
    teb
}

#[link_section = ".text"]
/// Get a pointer to the Thread Environment Block (TEB)
#[cfg(target_pointer_width = "32")]
pub unsafe fn get_teb() -> *mut ntapi::ntpebteb::TEB 
{
    let teb: *mut ntapi::ntpebteb::TEB;
    asm!("mov {teb}, fs:[0x18]", teb = out(reg) teb);
    teb
}

#[link_section = ".text"]
/// Get a pointer to the Process Environment Block (PEB)
pub unsafe fn get_peb() -> *mut PEB 
{
    let teb = get_teb();
    let peb = (*teb).ProcessEnvironmentBlock;
    peb
}