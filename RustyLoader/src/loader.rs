use core::{ffi::c_void, ptr::null_mut, slice::from_raw_parts, mem::{transmute, size_of}, arch::asm, ptr::read, ptr::write};
use ntapi::{ntpebteb::PEB, ntldr::LDR_DATA_TABLE_ENTRY, winapi::um::winnt::{IMAGE_DATA_DIRECTORY}};
use windows_sys::{
    core::PCSTR,
    Win32::{
        Foundation::{BOOL, FARPROC, HANDLE, HINSTANCE},
        System::{
            Diagnostics::{Debug::{
                IMAGE_NT_HEADERS64, IMAGE_NT_HEADERS32,
                IMAGE_SECTION_HEADER, IMAGE_DIRECTORY_ENTRY_EXPORT, IMAGE_DIRECTORY_ENTRY_BASERELOC, IMAGE_DIRECTORY_ENTRY_IMPORT,
            }},
            Memory::{
                MEM_COMMIT, MEM_RESERVE,
                PAGE_EXECUTE_READWRITE, PAGE_PROTECTION_FLAGS,
                VIRTUAL_ALLOCATION_TYPE,
            },
            SystemServices::{
                DLL_PROCESS_ATTACH, IMAGE_EXPORT_DIRECTORY, IMAGE_BASE_RELOCATION, IMAGE_REL_BASED_HIGHLOW, IMAGE_REL_BASED_DIR64, IMAGE_IMPORT_DESCRIPTOR, IMAGE_ORDINAL_FLAG64, IMAGE_ORDINAL_FLAG32, IMAGE_IMPORT_BY_NAME, IMAGE_RELOCATION,
            }, WindowsProgramming::IMAGE_THUNK_DATA64,WindowsProgramming::IMAGE_THUNK_DATA32,
        },
    },
};



#[repr(C)]
pub struct IMAGE_DOS_HEADER {
    pub e_magic: u16,    // Magic number
    pub e_cblp: u16,     // Bytes on last page of file
    pub e_cp: u16,       // Pages in file
    pub e_crlc: u16,     // Relocations
    pub e_cparhdr: u16,  // Size of header in paragraphs
    pub e_minalloc: u16, // Minimum extra paragraphs needed
    pub e_maxalloc: u16, // Maximum extra paragraphs needed
    pub e_ss: u16,       // Initial (relative) SS value
    pub e_sp: u16,       // Initial SP value
    pub e_csum: u16,     // Checksum
    pub e_ip: u16,       // Initial IP value
    pub e_cs: u16,       // Initial (relative) CS value
    pub e_lfarlc: u16,   // File address of relocation table
    pub e_ovno: u16,     // Overlay number
    pub e_res: [u16; 4], // Reserved words
    pub e_oemid: u16,    // OEM identifier (for e_oeminfo)
    pub e_oeminfo: u16,  // OEM information; e_oemid specific
    pub e_res2: [u16; 10], // Reserved words
    pub e_lfanew: i32,   // File address of new exe header
}

pub fn dbj2_hash(buffer: &[u8]) -> u32 
{
    let mut hsh: u32 = 5381;
    let mut iter: usize = 0;
    let mut cur: u8;

    while iter < buffer.len() 
    {
        cur = buffer[iter];

        if cur == 0 
        {
            iter += 1;
            continue;
        }

        if cur >= ('a' as u8) 
        {
            cur -= 0x20;
        }

        hsh = ((hsh << 5).wrapping_add(hsh)) + cur as u32;
        iter += 1;
    }

    return hsh;
}

pub unsafe fn grab_str_from_ptr(ptr: usize) -> &'static [u8]{
    // Take a slice of u8 from pointer and increments it with i
    // For each element j of the slice, check if last element is null byte
    // If null byte is found, return slice without null byte 

    let mut i:usize = 2;
    let mut exit=false;
    loop {
        let string_slice_without_null_char = from_raw_parts(ptr as *const u8, i-1);
        let string_slice = from_raw_parts(ptr as *const u8, i);

        for j in 0..=i-1{
            if string_slice[j] == 0 {
                return  string_slice_without_null_char
            }
        }
        i+=1;
    }

}
#[no_mangle]
pub unsafe extern "system" fn ReflectiveLoader(p: *mut c_void) ->   usize {

    // STEP 1: process the kernels exports for the functions our loader needs...

    // modules hashes generated by dbj2_hash
    let KERNEL32_HASH: u32 = 0x6ddb9555;
    let NTDLL_HASH: u32 = 0x1edab0ed;
    let LOAD_LIBRARY_A_HASH: u32 = 0xb7072fdb;
    let GET_PROC_ADDRESS_HASH: u32 = 0xdecfc1bf;
    let VIRTUAL_ALLOC_HASH: u32 = 0x97bc257;
    let VIRTUAL_PROTECT_HASH: u32 = 0xe857500d;
    let FLUSH_INSTRUCTION_CACHE_HASH: u32 = 0x6269b87f;
    let VIRTUAL_FREE_HASH: u32 = 0xe144a60e;
    let EXIT_THREAD_HASH: u32 = 0xc165d757;

    // Create function pointers
    #[allow(non_camel_case_types)]
    type fnLoadLibraryA = unsafe extern "system" fn(lplibfilename: PCSTR) -> HINSTANCE;
    let mut LoadLibraryA = transmute::<_, fnLoadLibraryA>(0x00000 as  usize); //dummy assignation

    #[allow(non_camel_case_types)]
    type fnGetProcAddress = unsafe extern "system" fn(hmodule: HINSTANCE, lpprocname: PCSTR) -> FARPROC;
    let mut GetProcAddress = transmute::<_, fnGetProcAddress>(0x00000 as  usize); //dummy assignation

    #[allow(non_camel_case_types)]
    type fnFlushInstructionCache = unsafe extern "system" fn(hprocess: HANDLE, lpbaseaddress: *const c_void, dwsize: usize) -> BOOL;
    let mut FlushInstructionCache = transmute::<_, fnFlushInstructionCache>(0x00000 as  usize); //dummy assignation

    #[allow(non_camel_case_types)]
    type fnVirtualAlloc = unsafe extern "system" fn(lpaddress: *const c_void, dwsize: usize, flallocationtype: VIRTUAL_ALLOCATION_TYPE, flprotect: PAGE_PROTECTION_FLAGS) -> *mut c_void;
    let mut VirtualAlloc = transmute::<_, fnVirtualAlloc>(0x00000 as  usize); //dummy assignation

    let var1 = 2;
    let var2 = 3;
    let loaded_module_base = p as *mut c_void;
    let dos_header: *mut IMAGE_DOS_HEADER = loaded_module_base as *mut IMAGE_DOS_HEADER;
    // unsafe {
    let e_magic = (*dos_header).e_magic;
    let peb: *mut PEB = get_peb();
    let pLdr: *mut ntapi::ntpsapi::PEB_LDR_DATA = (*peb).Ldr;
    //Flink contains a pointer to next entry
    let mut module_list: *mut ntapi::ntldr::LDR_DATA_TABLE_ENTRY = (*pLdr).InLoadOrderModuleList.Flink as *mut LDR_DATA_TABLE_ENTRY;// get the first entry of the InMemoryOrder module list
    let mut current_module_list: *mut LDR_DATA_TABLE_ENTRY = module_list;
    let mut dll_found_count = 0;
    loop {
        let pBuffer: *mut u16 = (*current_module_list).BaseDllName.Buffer;
        let module_length: usize = (*current_module_list).BaseDllName.Length  as usize ;  // we divide by 2 because each character is 2 bytes

        let dll_name_slice = from_raw_parts(pBuffer as *const u8, module_length);
        let module_hash: u32 = dbj2_hash(dll_name_slice);

        if module_hash == KERNEL32_HASH {
            // incremet counter to stop when both dll found
            dll_found_count += 1;

            // get this modules base address
            let module_base_address: *mut  usize = (*current_module_list).DllBase as *mut usize;

            // get the VA of the modules NT Header
            let module_dos_headers: *mut IMAGE_DOS_HEADER = module_base_address as *mut IMAGE_DOS_HEADER;
            let module_nt_headers_ptr = module_base_address as usize + (*module_dos_headers).e_lfanew as  usize;

            // module_export_dir 
            let module_nt_headers: *mut IMAGE_NT_HEADERS32 = module_nt_headers_ptr as *mut IMAGE_NT_HEADERS32;
            let module_export_dir =  (*module_nt_headers).OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT as usize];

            // get the VA of the export directory
            let module_image_data_directory:  usize = module_base_address as  usize + module_export_dir.VirtualAddress as usize;
            let module_image_data_directory2:  u32 =  module_export_dir.VirtualAddress as u32;

            // get the VA for the array of name pointers
            let module_image_export_directory : *mut IMAGE_EXPORT_DIRECTORY = module_image_data_directory as *mut IMAGE_EXPORT_DIRECTORY;
            let mut module_AddressOfNames: *const usize = (module_base_address as usize + (*module_image_export_directory).AddressOfNames as usize) as *const usize;
            
            // get the VA for the array of name ordinals
            let mut module_AddressOfOrdinals: *const u16 = (module_base_address as usize + (*module_image_export_directory).AddressOfNameOrdinals as usize) as *const u16;
            let mut counter = 0;
            // for i in 0..(*module_image_export_directory).NumberOfNames{
            //     let name_addr = (module_base_address as usize + names[i as usize] as usize) as *const i8;
            // }\
            let mut count = 0;
            while counter != 3{
                // get AddressOfNames value (RVA to function names array)
                let module_AddressOfNames_dereferenced: u32 = *(module_AddressOfNames as *const u32) ;
                
                // get offset of AddressOfNames value
                let function_name_ptr = module_base_address as usize + module_AddressOfNames_dereferenced as usize;

                //get slice of u8 from each function name
                let mut function_name_slice = grab_str_from_ptr(function_name_ptr);

                // get hash value of the function name
                let function_name_hash: u32 = dbj2_hash(function_name_slice);

                if function_name_hash == GET_PROC_ADDRESS_HASH || function_name_hash == LOAD_LIBRARY_A_HASH || function_name_hash == VIRTUAL_ALLOC_HASH {
                    counter += 1;
                    // get the VA for the array of addresses
                    let mut AddressOfFunctions: *const u32  = (module_base_address as usize + (*module_image_export_directory).AddressOfFunctions as usize) as *const u32;

                    // use this functions name ordinal as an index into the array of name pointers
                    let ordinal_value = *(module_AddressOfOrdinals as *const u16) as isize;
                    AddressOfFunctions = (AddressOfFunctions as *const u32).offset(ordinal_value) as *const u32;
                    
                    // get function VA
                    let AddressOfFunctions_VA = module_base_address  as  usize + *(AddressOfFunctions as *const u32) as usize;

                    // store this functions VA
                    if function_name_hash == LOAD_LIBRARY_A_HASH {
                        //let LoadLibraryA = transmute::<_, fnLoadLibraryA>(AddressOfFunctions_VA);
                        //let LoadLibraryA: *mut fnLoadLibraryA = AddressOfFunctions_VA as *mut fnLoadLibraryA;
                        LoadLibraryA = transmute::<_, fnLoadLibraryA>(AddressOfFunctions_VA);
                    }
                    if function_name_hash == GET_PROC_ADDRESS_HASH {
                        //let GetProcAddress: *mut fnGetProcAddress = AddressOfFunctions_VA as *mut fnGetProcAddress;
                        GetProcAddress = transmute::<_, fnGetProcAddress>(AddressOfFunctions_VA);
                    }
                    if function_name_hash == VIRTUAL_ALLOC_HASH {
                        //VirtualAlloc = AddressOfFunctions_VA as *mut fnVirtualAlloc;
                        VirtualAlloc = transmute::<_, fnVirtualAlloc>(AddressOfFunctions_VA);
                        //VirtualAlloc = Some(transmute::<_, fnVirtualAlloc>(AddressOfFunctions_VA));
                        

                    }
 
                }

                
                // get the next exported function name
                // offset function offsets the pointer by the size of the type the pointer is pointing to
                // module_AddressOfNames = module_AddressOfNames.offset(1); //add dword
                module_AddressOfNames = (module_AddressOfNames as *const u16).offset(2) as *const usize; // add 2x u16 = DWORD

                // get the next exported function name ordinal
                module_AddressOfOrdinals = (module_AddressOfOrdinals as *const u16).offset(1) as *const u16; // add 1x u16 = WORD
                count += 1;

            }
            
        }
        else if  module_hash == NTDLL_HASH {
            // incremet counter to stop when both dll found
            dll_found_count += 1;

            // get this modules base address
            let module_base_address: *mut  usize = (*current_module_list).DllBase as *mut usize;

            // get the VA of the modules NT Header
            let module_dos_headers: *mut IMAGE_DOS_HEADER = module_base_address as *mut IMAGE_DOS_HEADER;
            let module_nt_headers_ptr = module_base_address as usize + (*module_dos_headers).e_lfanew as  usize;

            // module_export_dir 
            let module_nt_headers: *mut IMAGE_NT_HEADERS32 = module_nt_headers_ptr as *mut IMAGE_NT_HEADERS32;
            let module_export_dir =  (*module_nt_headers).OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT as usize];

            // get the VA of the export directory
            let module_image_data_directory:  usize = module_base_address as  usize + module_export_dir.VirtualAddress as usize;
            let module_image_data_directory2:  u32 =  module_export_dir.VirtualAddress as u32;

            // get the VA for the array of name pointers
            let module_image_export_directory : *mut IMAGE_EXPORT_DIRECTORY = module_image_data_directory as *mut IMAGE_EXPORT_DIRECTORY;
            let mut module_AddressOfNames: *const usize = (module_base_address as usize + (*module_image_export_directory).AddressOfNames as usize) as *const usize;
            
            // get the VA for the array of name ordinals
            let mut module_AddressOfOrdinals: *const u16 = (module_base_address as usize + (*module_image_export_directory).AddressOfNameOrdinals as usize) as *const u16;
            let mut counter = 0;
            // for i in 0..(*module_image_export_directory).NumberOfNames{ 
            //     let name_addr = (module_base_address as usize + names[i as usize] as usize) as *const i8;
            // }\
            let mut count = 0;
            while counter != 1{
                // get AddressOfNames value (RVA to function names array)
                let module_AddressOfNames_dereferenced: u32 = *(module_AddressOfNames as *const u32) ;
                // get offset of AddressOfNames value
                let function_name_ptr = module_base_address as usize + module_AddressOfNames_dereferenced as usize;

                //get slice of u8 from each function name
                let mut function_name_slice = grab_str_from_ptr(function_name_ptr);

                // get hash value of the function name
                let function_name_hash: u32 = dbj2_hash(function_name_slice);

                if function_name_hash == FLUSH_INSTRUCTION_CACHE_HASH {
                    counter += 1;

                    // get the VA for the array of addresses
                    let mut AddressOfFunctions: *const u32  = (module_base_address as usize + (*module_image_export_directory).AddressOfFunctions as usize) as *const u32;

                    // use this functions name ordinal as an index into the array of name pointers
                    let ordinal_value = *(module_AddressOfOrdinals as *const u16) as isize;
                    AddressOfFunctions = (AddressOfFunctions as *const u32).offset(ordinal_value) as *const u32;
                    
                    // get function VA
                    let AddressOfFunctions_VA = module_base_address  as  usize + *(AddressOfFunctions as *const u32) as usize;
                    // store this functions VA
                    if function_name_hash == FLUSH_INSTRUCTION_CACHE_HASH {
                        //let FlushInstructionCache: *mut fnFlushInstructionCache = AddressOfFunctions_VA as *mut fnFlushInstructionCache;
                        FlushInstructionCache = transmute::<_, fnFlushInstructionCache>(AddressOfFunctions_VA);
                    }
                }
                
                // get the next exported function name
                // offset function offsets the pointer by the size of the type the pointer is pointing to
                // module_AddressOfNames = module_AddressOfNames.offset(1); //add dword
                module_AddressOfNames = (module_AddressOfNames as *const u16).offset(2) as *const usize; // add 2x u16 = DWORD
                // get the next exported function name ordinal
                module_AddressOfOrdinals = (module_AddressOfOrdinals as *const u16).offset(1) as *const u16; // add 1x u16 = WORD
                count += 1;

            }

        }

        // move to the next entry
        current_module_list = (*current_module_list).InLoadOrderLinks.Flink as *mut ntapi::ntldr::LDR_DATA_TABLE_ENTRY;
        
        // stop when we're back at the start
        if current_module_list == module_list || dll_found_count == 2{
            break;
        }

    }
    // STEP 2: load our image into a new permanent location in memory...

    // get the VA of the NT Header for the PE to be loaded
    let loaded_module_DOS_Headers: *mut IMAGE_DOS_HEADER = loaded_module_base as *mut IMAGE_DOS_HEADER;
    let NT_Headers_address = loaded_module_base as usize + (*loaded_module_DOS_Headers).e_lfanew as usize;
    let loaded_module_NT_Headers: *mut IMAGE_NT_HEADERS32 = NT_Headers_address as *mut IMAGE_NT_HEADERS32;


	// allocate all the memory for the DLL to be loaded into. we can load at any address because we will  
	// relocate the image. Also zeros all memory and marks it as READ, WRITE and EXECUTE to avoid any problems.
    let mut new_base_address = VirtualAlloc(null_mut(), (*loaded_module_NT_Headers).OptionalHeader.SizeOfImage as usize, MEM_RESERVE|MEM_COMMIT, PAGE_EXECUTE_READWRITE );

    // step 2 : copy the headers
    let sizeofheaders = (*loaded_module_NT_Headers).OptionalHeader.SizeOfHeaders;
    let mut sizeofheaders_tmp = sizeofheaders;
    let mut loaded_module_base_tmp: *mut c_void = loaded_module_base;
    let mut new_base_address_tmp = new_base_address;

    while sizeofheaders_tmp > 0 {
        *(new_base_address_tmp as *mut u8) = *(loaded_module_base_tmp as *mut u8);
        sizeofheaders_tmp -= 1;
        loaded_module_base_tmp = (loaded_module_base_tmp as *mut u8).add(1) as *mut c_void;
        new_base_address_tmp = (new_base_address_tmp as *mut u8).add(1) as *mut c_void;
    }

    // step 3 : load all the sections

    // get the VA of the first section header
    let optional_headers_ptr = &(*loaded_module_NT_Headers).OptionalHeader as *const _ as usize; // get a pointer to OptionalHeader
    let mut first_section: *mut c_void = (optional_headers_ptr as  usize + (*loaded_module_NT_Headers).FileHeader.SizeOfOptionalHeader as usize) as *mut c_void;

    // itterate through all sections, loading them into memory.
    let mut number_of_sections =  (*loaded_module_NT_Headers).FileHeader.NumberOfSections;

    while number_of_sections > 0 {

        // get the RVA of the section
        let mut section_headers: *mut IMAGE_SECTION_HEADER = first_section as *mut IMAGE_SECTION_HEADER; 
        let mut section_RVA = (*section_headers).VirtualAddress;

        // get the a ptr to new section VA
        let mut new_section_VA = (new_base_address as *mut u8).add(section_RVA as usize);

        // get a ptr the section data
        let mut section_data = (loaded_module_base as usize + (*section_headers).PointerToRawData as usize) as *mut usize;

        // get the section data size
        let mut section_data_size = (*section_headers).SizeOfRawData;
        
        // copy the data
        while section_data_size > 0 {
            *(new_section_VA as *mut u8) = *(section_data as *mut u8);
            section_data_size -= 1;
            new_section_VA = (new_section_VA as *mut u8).add(1);
            section_data = (section_data as *mut u8).add(1) as *mut usize;
        }

        // get IMAGE_SECTION_HEADER_size 
		let IMAGE_SECTION_HEADER_size = core::mem::size_of::<IMAGE_SECTION_HEADER>(); // usually 40 bytes
        // go to the next section headers 
        first_section = (first_section as *mut u8).add(40) as *mut c_void;
        
        number_of_sections -= 1;
    }


    // STEP 4: process our images import table...

    // get pointer to the address of the import directory
    let import_dir_addr: usize =  &(*loaded_module_NT_Headers).OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT as usize] as *const _ as usize;;
    
    // We read the import dir RVA of the import dir from the raw (not loaded) dll header and we add it to the new base address
    let directory_import : *mut IMAGE_DATA_DIRECTORY = import_dir_addr as *mut IMAGE_DATA_DIRECTORY; 

    // address of first Import Dir entry
    let first_entry = (new_base_address as *mut u8).add((*directory_import).VirtualAddress as usize);
                
    // cast first import dir entry
    let mut first_entry_DESCRIPTOR : *mut IMAGE_IMPORT_DESCRIPTOR = first_entry as *mut IMAGE_IMPORT_DESCRIPTOR; 
    //let name_ptr = (new_base_address as *mut u8).add((*first_entry_DESCRIPTOR).Name as usize);;

    // contains ptr to the name of the first import dll
    // let mut name_ptr = (new_base_address as *mut u8).add((*first_entry_DESCRIPTOR).Name as usize);
    
    // let mut name_ptr_slice = grab_str_from_ptr(name_ptr as usize); //useless, to remove
    while (*first_entry_DESCRIPTOR).Name != 0x0 {
        // contains ptr to the name of the imported dll
        let mut dll_name_ptr = (new_base_address as *mut u8).add((*first_entry_DESCRIPTOR).Name as usize);
    
        let mut dll_name_ptr_slice = grab_str_from_ptr(dll_name_ptr as usize); //useless, to remove

        // use LoadLibraryA to load the imported modules
        let dll_handle = LoadLibraryA(dll_name_ptr);

        // get VA of the OriginalFirstThunk
        let mut OriginalFirstThunk = (new_base_address as *mut u8).add((*first_entry_DESCRIPTOR).Anonymous.OriginalFirstThunk as usize) as *mut usize;

        // get VA of the IAT (via first thunk not origionalfirstthunk)
        let mut FirstThunk_ptr: *mut usize = (new_base_address as *mut u8).add((*first_entry_DESCRIPTOR).FirstThunk as usize) as *mut usize;
        
        // iterate through all imported functions
        // thunk contains address of the IAT entry containing the function RVA
        while *(FirstThunk_ptr as *mut u32) != 0 {
            
            // sanity check OriginalFirstThunk as some compilers only import by FirstThunk. Will enter the if condition it import by ordinal
            let mut imagethunkdata : *mut IMAGE_THUNK_DATA32 = OriginalFirstThunk as * mut IMAGE_THUNK_DATA32; 
            
                        
            if !OriginalFirstThunk.is_null()  && (IMAGE_ORDINAL_FLAG32 & (*imagethunkdata).u1.Ordinal) != 0{ //IMAGE_ORDINAL_FLAG64 equal to 0x8000000000000000
                
                // get the VA of the modules NT Header
                let mut NT_Headers_address = loaded_module_base as usize + (*loaded_module_DOS_Headers).e_lfanew as usize;
            
                // get the address of the modules export directory entry
                let mut module_nt_headers: *mut IMAGE_NT_HEADERS32 = NT_Headers_address as *mut IMAGE_NT_HEADERS32;
                let mut export_dir_entry_ptr =  (*module_nt_headers).OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT as usize];

                // get the VA of the export directory
                let mut export_dir_ptr:  usize = loaded_module_base as  usize + export_dir_entry_ptr.VirtualAddress as usize;

                // get the VA for the array of addresses
                let module_image_export_directory : *mut IMAGE_EXPORT_DIRECTORY = export_dir_ptr as *mut IMAGE_EXPORT_DIRECTORY;
                let mut array_address = loaded_module_base as usize  + ((*module_image_export_directory).AddressOfFunctions as usize) ;

                // use the import ordinal (- export ordinal base) as an index into the array of addresses

                //array_address = array_address + (IMAGE_ORDINAL((*imagethunkdata).u1.Ordinal) as usize - (*module_image_export_directory).Base as usize* 4) as usize;
                array_address = array_address + (  ((*imagethunkdata).u1.Ordinal & 0xFFF) as usize - (*module_image_export_directory).Base as usize* 4) as usize;
                // // patch in the address for this imported function
                *(FirstThunk_ptr as *mut u32)  = (loaded_module_base as  usize + *(array_address as *mut u32) as  usize) as  u32;
            }
            else {
                // get the VA of this functions import by name struct
                let mut function_import_VA = (new_base_address as *mut u8).add((*(FirstThunk_ptr as *mut u32)) as usize);

                // cast function_import_VA to IMAGE_IMPORT_BY_NAME struct
                let mut function_image_import_by_name : *mut IMAGE_IMPORT_BY_NAME = function_import_VA as *mut IMAGE_IMPORT_BY_NAME;

                // Get function name from IMAGE_IMPORT_BY_NAME
                let mut function_name = (*function_image_import_by_name).Name.as_ptr();

                // get function VA from GetProcAddress
                let mut function_VA:  usize = GetProcAddress(dll_handle, function_name).unwrap() as  _;

                // Patch the IAT
                *(FirstThunk_ptr as *mut usize) = function_VA  ;

            }
            // get next pointer
            FirstThunk_ptr = (FirstThunk_ptr as *mut u32).add(1) as *mut usize;
        }
      

        // get the next entry
        first_entry_DESCRIPTOR = (first_entry_DESCRIPTOR as usize + size_of::<IMAGE_IMPORT_DESCRIPTOR>() as usize) as _;

        
    }


    // STEP 5: process all of our images relocations...

    // calculate the base address delta and perform relocations (even if we load at desired image base)
    let base_address_delta = (new_base_address  as isize - (*loaded_module_NT_Headers).OptionalHeader.ImageBase as isize);

    // get the address of the relocation directory
    let mut relocation_directory =  (*loaded_module_NT_Headers).OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC as usize];

    // check if their are any relocations present
    if relocation_directory.Size != 0 {

        // get the first entry (IMAGE_BASE_RELOCATION)
        let relocation_directory_ptr = &mut relocation_directory as *mut _;
        let relocation_directory_IMAGE_DATA_DIRECTORY : *mut IMAGE_DATA_DIRECTORY = relocation_directory_ptr as *mut IMAGE_DATA_DIRECTORY; 
        let mut first_entry =  (new_base_address as *mut u8).add(((*relocation_directory_IMAGE_DATA_DIRECTORY).VirtualAddress) as usize);

        // and we itterate through all entries...
        let mut first_entry_IMAGE_BASE_RELOC = first_entry as *mut IMAGE_BASE_RELOCATION;
        let mut first_entry_IMAGE_BASE_RELOC_size_block = (*first_entry_IMAGE_BASE_RELOC).SizeOfBlock;

        while (first_entry_IMAGE_BASE_RELOC_size_block != 0) {
            
            // get the VA for this relocation block
            //let relocation_block_VA = new_base_address.add((*first_entry_IMAGE_BASE_RELOC).VirtualAddress as usize) as isize; 
            let relocation_block_VA = new_base_address  as usize +  (*first_entry_IMAGE_BASE_RELOC).VirtualAddress as usize;

            // get the number of entries in this relocation block
            let mut entries_number = ((*first_entry_IMAGE_BASE_RELOC).SizeOfBlock as usize - size_of::<IMAGE_BASE_RELOCATION>()) / size_of::<u16>() ;

            // get the first entry in the current relocation block
            //let first_entry_in_block: *mut usize = first_entry.add(size_of::<IMAGE_BASE_RELOCATION>()) as *mut usize; // IMAGE_BASE_RELOCATION size should be 8
            let first_entry_in_block: *const u16 = first_entry.add(size_of::<IMAGE_BASE_RELOCATION>()) as *const u16; // IMAGE_BASE_RELOCATION size should be 8
            
            // we itterate through all the entries in the current block...
            
            for i in 0..entries_number {

				// perform the relocation, skipping IMAGE_REL_BASED_ABSOLUTE as required.
				// we dont use a switch statement to avoid the compiler building a jump table
				// which would not be very position independent!
                let type_field: u32 = (first_entry_in_block.offset(i as isize).read() >> 12) as u32;
                let offset = first_entry_in_block.offset(i as isize).read() & 0xFFF;
                if type_field == IMAGE_REL_BASED_DIR64 || type_field == IMAGE_REL_BASED_HIGHLOW {
                    // Read the original value at the final address
                    let ogaddress =  read((relocation_block_VA + offset as usize) as *const usize);

                    // Calculate the fixed address of the relocation
                    let fixedaddress = (ogaddress as isize + base_address_delta as isize) as isize;

                    //Write the fixed address to the final address
                    write((relocation_block_VA + offset as usize) as *mut usize, fixedaddress as usize);

                }
            }


            // get the next entry in the relocation directory
            first_entry = first_entry.add(first_entry_IMAGE_BASE_RELOC_size_block as usize);
            first_entry_IMAGE_BASE_RELOC = first_entry as *mut IMAGE_BASE_RELOCATION;
            first_entry_IMAGE_BASE_RELOC_size_block = (*first_entry_IMAGE_BASE_RELOC).SizeOfBlock;

        }
    }
    // STEP 6: call our images entry point

    // get the VA of our newly loaded DLL/EXE's entry point
    let entry_point = new_base_address as usize + (*loaded_module_NT_Headers).OptionalHeader.AddressOfEntryPoint as usize;

    // We must flush the instruction cache to avoid stale code being used which was updated by our relocation processing.
    FlushInstructionCache(-1 as _, null_mut(), 0);

    // call our respective entry point, fudging our hInstance value
    #[allow(non_camel_case_types)]
    type fnDllMain = unsafe extern "system" fn(module: HINSTANCE, call_reason: u32, reserved: *mut c_void) -> BOOL;

    #[allow(non_snake_case)]
    let DllMain = transmute::<_, fnDllMain>(entry_point);

    DllMain(new_base_address as _, DLL_PROCESS_ATTACH, loaded_module_base as _);

    // STEP 8: return our new entry point address so whatever called us can call DllMain() if needed.
    return entry_point;

    
}


#[link_section = ".text"]
/// Get a pointer to the Thread Environment Block (TEB)
#[cfg(target_pointer_width = "64")]
pub unsafe fn get_teb() -> *mut ntapi::ntpebteb::TEB 
{
    let teb: *mut ntapi::ntpebteb::TEB;
    asm!("mov {teb}, gs:[0x30]", teb = out(reg) teb);
    teb
}

#[link_section = ".text"]
/// Get a pointer to the Thread Environment Block (TEB)
#[cfg(target_pointer_width = "32")]
pub unsafe fn get_teb() -> *mut ntapi::ntpebteb::TEB 
{
    let teb: *mut ntapi::ntpebteb::TEB;
    asm!("mov {teb}, fs:[0x18]", teb = out(reg) teb);
    teb
}

#[link_section = ".text"]
/// Get a pointer to the Process Environment Block (PEB)
pub unsafe fn get_peb() -> *mut PEB 
{
    let teb = get_teb();
    let peb = (*teb).ProcessEnvironmentBlock;
    peb
}