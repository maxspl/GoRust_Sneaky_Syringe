package utils

import (
	b64 "encoding/base64"
	"fmt"
	"strconv"
	"syscall"
	"unsafe"

	"github.com/buger/jsonparser"
)

func FromUtils() {
	fmt.Println("hello from utils")
}

//go:noescape
func Add(x, y int) int
func CallAsm() {
	a := Add(10, 20)
	fmt.Println("a ici :", a)
}

//go:noescape
func bpSyscall(callid uint16, argh ...uintptr) (errcode uint32)
func Syscall(callid uint16, argh ...uintptr) (errcode uint32, err error) {
	errcode = bpSyscall(callid, argh...)

	if errcode != 0 {
		err = fmt.Errorf("non-zero return from syscall")
	}
	return errcode, err
}

func XorData(encoded []uint8) string {
	var decoded []int
	for _, i := range encoded {
		decoded = append(decoded, int(i^0xde))
	}
	var str string
	for _, code := range decoded {
		str += string(rune(code))
	}
	return str
}

func findNearestLowerValue(arr []int, target int) int {
	left, right := 0, len(arr)-1
	result := -1

	for left <= right {
		mid := left + (right-left)/2

		if arr[mid] == target {
			return arr[mid]
		} else if arr[mid] < target {
			result = arr[mid] // update result as arr[mid] is less than target
			left = mid + 1
		} else {
			right = mid - 1
		}
	}

	return result
}

func ResolveSyscallid(API string) (error, uint16) {
	// get OS build
	os_build := Retrieve_OS_build()

	// Contains b64 json with reversed function names - generated by get_syscalls.py
	syscalls := "pfynrLGzu5Oyv6uqrLeIu6q/vbGysp+qkPzk/qX8/fzk/uzt8v787+7u6O/85P7s6vL+/O/u7Oru/OT+7Ory/vzv7uvm6Pzk/uzq8v787+rt5+385P7s6vL+/O/r7ujt/OT+7Ory/vzv6Ozn5/zk/uzq8v787+nv7er85P7s6vL+/O/p6ejt/OT+7Ory/vzv5u3o7Pzk/uzq8v787+bt6O385P7s6vL+/O/n7urv/OT+7Ory/vzs7u3q5vzk/uzq8v787Ozu7u785P7s6vL+/Ozs6Ozv/OT+7Ory/vzs7Ojt7/zk/uzq8v787O3q6+/85P7s6vL+/Ozt6ubv/OT+7Ory/vzs6+fu6/zk/uzq8v787Ovn5uz85P7s6vL+/Ozr5+fp/OT+7Oqj8v78p6yxs7uTsr+rqqy3iLuqt6yJqpD85P6l/P385P7q6ury/vzv7u7o7/zk/uvm8v787+7s6u785P7r5vL+/O/u6+bo/OT+6+by/vzv6u3n7fzk/uvm8v787+vu6O385P7r5vL+/O/o7Ofn/OT+6+by/vzv6e/t6vzk/uvm8v787+np6O385P7r5vL+/O/m7ejs/OT+6+by/vzv5u3o7fzk/uvm8v787+fu6u/85P7r5vL+/Ozu7erm/OT+6+by/vzs7O7u7vzk/uvm8v787Ozo7O/85P7r5vL+/Ozs6O3v/OT+6+by/vzs7err7/zk/uvm8v787O3q5u/85P7r5vL+/Ozr5+7r/OT+6+by/vzs6+fm7Pzk/uvm8v787Ovn5+n85P7r5qPy/vymm7q/u6y2iruqv7usnaqQ/OT+pfz9/OT+7+7q8v787+7u6O/85P7v5u/y/vzv7uzq7vzk/u/p5/L+/O/u6+bo/OT+7+bu8v787+rt5+385P7v5uzy/vzv6+7o7fzk/u/m6/L+/O/o7Ofn/OT+7+bo8v787+nv7er85P7v5uny/vzv6eno7fzk/u/m5vL+/O/m7ejs/OT+7+bn8v787+bt6O385P7v5ufy/vzv5+7q7/zk/u/n6vL+/Ozu7erm/OT+7+fo8v787Ozu7u785P7v5+ny/vzs7Ojs7/zk/u/n5/L+/Ozs6O3v/OT+7+fn8v787O3q6+/85P7v5+fy/vzs7erm7/zk/u/n5/L+/Ozr5+7r/OT+7O7u8v787Ovn5uz85P7s7u7y/vzs6+fn6fzk/uzu7qOj"

	// Decode and unxored dataa
	decoded, err := b64.StdEncoding.DecodeString(syscalls)
	if err != nil {
		fmt.Println("Error, cannot decode base64. Err :", err)
	}

	str := XorData(decoded)

	// Convert json string to byte slice
	byteSlice := []byte(str)

	// Stored all os builds to a slice
	var OS_version []string
	jsonparser.ObjectEach(byteSlice, func(key []byte, value []byte, dataType jsonparser.ValueType, offset int) error {
		//fmt.Printf("Key: '%s'\n Value: '%s'\n Type: %s\n", string(key), string(value), dataType)
		OS_version = append(OS_version, string(key))
		return nil
	}, API)
	OS_version = OS_version[1:] // remove the first element as it contains #, not a valid build

	// Convert the slice of string to a slice of int
	var osVersionInts []int
	for _, v := range OS_version {
		intValue, err := strconv.Atoi(v)
		if err != nil {
			// Handle the error according to your needs
			fmt.Println("Error converting string to int:", err)
			continue
		}
		osVersionInts = append(osVersionInts, intValue)
	}

	//Find the nearest build value
	nearestLowerValue := findNearestLowerValue(osVersionInts, os_build)
	var os_build_near string
	if nearestLowerValue != -1 {
		//fmt.Printf("The nearest build value to %d is %d\n", 19045, nearestLowerValue)
		os_build_near = strconv.Itoa(nearestLowerValue)
	} else {
		//fmt.Println("No build value found")
		return fmt.Errorf("Error cannot resolve build value"), 0
	}

	//Finally get the syscall id
	id, _ := jsonparser.GetInt(byteSlice, API, os_build_near)
	return nil, uint16(id)
}

func Retrieve_OS_build() int {
	type OSVERSIONINFOEXW struct {
		DwOSVersionInfoSize uint32
		DwMajorVersion      uint32
		DwMinorVersion      uint32
		DwBuildNumber       uint32
		DwPlatformId        uint32
		SzCSDVersion        [128]uint16
		WServicePackMajor   uint16
		WServicePackMinor   uint16
		WSuiteMask          uint16
		WProductType        byte
		WReserved           byte
	}
	var osvi OSVERSIONINFOEXW
	osvi.DwOSVersionInfoSize = uint32(unsafe.Sizeof(osvi))

	mod := syscall.NewLazyDLL("ntdll.dll")
	proc := mod.NewProc("RtlGetVersion")

	ret, _, _ := proc.Call(uintptr(unsafe.Pointer(&osvi)))
	if ret != 0 {
		fmt.Println("Call to RtlGetVersion failed!")
		return 0
	}
	return int(osvi.DwBuildNumber)

}
