package utils

import (
	b64 "encoding/base64"
	"fmt"
	"strconv"
	"syscall"
	"unsafe"

	"github.com/Binject/debug/pe"
	"github.com/buger/jsonparser"
	"golang.org/x/sys/windows"
)

func FromUtils() {
	fmt.Println("hello from utils")
}

//go:noescape
func Add(x, y int) int
func CallAsm() {
	a := Add(10, 20)
	fmt.Println("a ici :", a)
}

//go:noescape
func bpSyscall(callid uint16, argh ...uintptr) (errcode uint32)
func Syscall(callid uint16, argh ...uintptr) (errcode uint32, err error) {
	errcode = bpSyscall(callid, argh...)

	if errcode != 0 {
		err = fmt.Errorf("non-zero return from syscall")
	}
	return errcode, err
}

//go:noescape
func execIndirectSyscall(callid uint16, trampoline uintptr, argh ...uintptr) (errcode uint32)
func IndirectSyscall(callid uint16, trampoline uintptr, argh ...uintptr) (errcode uint32, err error) {
	errcode = execIndirectSyscall(callid, trampoline, argh...)

	if errcode != 0 {
		err = fmt.Errorf("non-zero return from indirect syscall")
	}
	return errcode, err
}

func XorData(encoded []uint8) string {
	var decoded []int
	for _, i := range encoded {
		decoded = append(decoded, int(i^0xde))
	}
	var str string
	for _, code := range decoded {
		str += string(rune(code))
	}
	return str
}

func findNearestLowerValue(arr []int, target int) int {
	left, right := 0, len(arr)-1
	result := -1

	for left <= right {
		mid := left + (right-left)/2

		if arr[mid] == target {
			return arr[mid]
		} else if arr[mid] < target {
			result = arr[mid] // update result as arr[mid] is less than target
			left = mid + 1
		} else {
			right = mid - 1
		}
	}

	return result
}

func ResolveSyscallid(API string) (error, uint16) {
	// get OS build
	os_build := Retrieve_OS_build()

	// Contains b64 json with reversed function names - generated by get_syscalls.py
	syscalls := "pfynrLGzu5Oyv6uqrLeIu6q/vbGysp+qkPzk/qX8/fzk/uzt8v787+7u6O/85P7s6vL+/O/u7Oru/OT+7Ory/vzv7uvm6Pzk/uzq8v787+rt5+385P7s6vL+/O/r7ujt/OT+7Ory/vzv6Ozn5/zk/uzq8v787+nv7er85P7s6vL+/O/p6ejt/OT+7Ory/vzv5u3o7Pzk/uzq8v787+bt6O385P7s6vL+/O/n7urv/OT+7Ory/vzs7u3q5vzk/uzq8v787Ozu7u785P7s6vL+/Ozs6Ozv/OT+7Ory/vzs7Ojt7/zk/uzq8v787O3q6+/85P7s6vL+/Ozt6ubv/OT+7Ory/vzs6+fu6/zk/uzq8v787Ovn5uz85P7s6vL+/Ozr5+fp/OT+7Oqj8v78p6yxs7uTsr+rqqy3iLuqt6yJqpD85P6l/P385P7q6ury/vzv7u7o7/zk/uvm8v787+7s6u785P7r5vL+/O/u6+bo/OT+6+by/vzv6u3n7fzk/uvm8v787+vu6O385P7r5vL+/O/o7Ofn/OT+6+by/vzv6e/t6vzk/uvm8v787+np6O385P7r5vL+/O/m7ejs/OT+6+by/vzv5u3o7fzk/uvm8v787+fu6u/85P7r5vL+/Ozu7erm/OT+6+by/vzs7O7u7vzk/uvm8v787Ozo7O/85P7r5vL+/Ozs6O3v/OT+6+by/vzs7err7/zk/uvm8v787O3q5u/85P7r5vL+/Ozr5+7r/OT+6+by/vzs6+fm7Pzk/uvm8v787Ovn5+n85P7r5qPy/vymm7q/u6y2iruqv7usnaqQ/OT+pfz9/OT+7+7q8v787+7u6O/85P7v5u/y/vzv7uzq7vzk/u/p5/L+/O/u6+bo/OT+7+bu8v787+rt5+385P7v5uzy/vzv6+7o7fzk/u/m6/L+/O/o7Ofn/OT+7+bo8v787+nv7er85P7v5uny/vzv6eno7fzk/u/m5vL+/O/m7ejs/OT+7+bn8v787+bt6O385P7v5ufy/vzv5+7q7/zk/u/n6vL+/Ozu7erm/OT+7+fo8v787Ozu7u785P7v5+ny/vzs7Ojs7/zk/u/n5/L+/Ozs6O3v/OT+7+fn8v787O3q6+/85P7v5+fy/vzs7erm7/zk/u/n5/L+/Ozr5+7r/OT+7O7u8v787Ovn5uz85P7s7u7y/vzs6+fn6fzk/uzu7qOj"

	// Decode and unxored dataa
	decoded, err := b64.StdEncoding.DecodeString(syscalls)
	if err != nil {
		fmt.Println("Error, cannot decode base64. Err :", err)
	}

	str := XorData(decoded)

	// Convert json string to byte slice
	byteSlice := []byte(str)

	// Stored all os builds to a slice
	var OS_version []string
	jsonparser.ObjectEach(byteSlice, func(key []byte, value []byte, dataType jsonparser.ValueType, offset int) error {
		//fmt.Printf("Key: '%s'\n Value: '%s'\n Type: %s\n", string(key), string(value), dataType)
		OS_version = append(OS_version, string(key))
		return nil
	}, API)
	OS_version = OS_version[1:] // remove the first element as it contains #, not a valid build

	// Convert the slice of string to a slice of int
	var osVersionInts []int
	for _, v := range OS_version {
		intValue, err := strconv.Atoi(v)
		if err != nil {
			// Handle the error according to your needs
			fmt.Println("Error converting string to int:", err)
			continue
		}
		osVersionInts = append(osVersionInts, intValue)
	}

	//Find the nearest build value
	nearestLowerValue := findNearestLowerValue(osVersionInts, os_build)
	var os_build_near string
	if nearestLowerValue != -1 {
		//fmt.Printf("The nearest build value to %d is %d\n", 19045, nearestLowerValue)
		os_build_near = strconv.Itoa(nearestLowerValue)
	} else {
		//fmt.Println("No build value found")
		return fmt.Errorf("Error cannot resolve build value"), 0
	}

	//Finally get the syscall id
	id, _ := jsonparser.GetInt(byteSlice, API, os_build_near)
	return nil, uint16(id)
}

func Retrieve_OS_build() int {
	type OSVERSIONINFOEXW struct {
		DwOSVersionInfoSize uint32
		DwMajorVersion      uint32
		DwMinorVersion      uint32
		DwBuildNumber       uint32
		DwPlatformId        uint32
		SzCSDVersion        [128]uint16
		WServicePackMajor   uint16
		WServicePackMinor   uint16
		WSuiteMask          uint16
		WProductType        byte
		WReserved           byte
	}
	var osvi OSVERSIONINFOEXW
	osvi.DwOSVersionInfoSize = uint32(unsafe.Sizeof(osvi))

	mod := syscall.NewLazyDLL("ntdll.dll")
	proc := mod.NewProc("RtlGetVersion")

	ret, _, _ := proc.Call(uintptr(unsafe.Pointer(&osvi)))
	if ret != 0 {
		fmt.Println("Call to RtlGetVersion failed!")
		return 0
	}
	return int(osvi.DwBuildNumber)

}

//go:noescape
func GetPEB() uintptr

func ParseNTDLL() uintptr {

	pPeb := GetPEB()
	fmt.Printf("PEB address : 0x%x\n", pPeb)

	PEB_struct := (*windows.PEB)(unsafe.Pointer(pPeb))
	//fmt.Printf("PEB_struct  : 0x%x\n", PEB_struct.Ldr)

	pLdr := (*PebLdrData)(unsafe.Pointer(PEB_struct.Ldr))
	fmt.Printf("PEB_LDR_DATA_struct address : 0x%p\n", pLdr)

	module_list := (*LdrDataTableEntry)(unsafe.Pointer(pLdr.InLoadOrderModuleList.Flink))
	currentModuleList := module_list //the list we incremented in the next for loop

	current_module_name_ptr := unsafe.Pointer(currentModuleList.BaseDllName.Buffer)                                          //grab the pbuffer of the first module
	module_name_length := uint16(currentModuleList.BaseDllName.Length)                                                       //grab the lenght of the name of the first module
	current_module_name, err := GrabStringFromPtrUTF16(uintptr(unsafe.Pointer(current_module_name_ptr)), module_name_length) //returns the module name from the pointer to the buffer
	if err != nil {
		fmt.Println("Error while calling GrabStringFromPtr.")
	}
	fmt.Printf("First module should be the program itself : %v\n", current_module_name)

	// nextModuleList := (*LdrDataTableEntry)(unsafe.Pointer(currentModuleList.InLoadOrderLinks.Flink))
	// fmt.Printf("currentModuleList : %p\n", nextModuleList)
	var ntdll_base uintptr
	ntdll_found := false
	for !ntdll_found {
		currentModuleList = (*LdrDataTableEntry)(unsafe.Pointer(currentModuleList.InLoadOrderLinks.Flink))                      //We grab the next module as Flink is a pointer to the next item
		current_module_name_ptr = unsafe.Pointer(currentModuleList.BaseDllName.Buffer)                                          //Buffer contains the dll name
		module_name_length = uint16(currentModuleList.BaseDllName.Length)                                                       //Length contains utf16 dll name length
		current_module_name, err = GrabStringFromPtrUTF16(uintptr(unsafe.Pointer(current_module_name_ptr)), module_name_length) //returns the module name from the pointer to the buffer
		if err != nil {
			fmt.Println("Error while calling GrabStringFromPtr.")
		}

		if current_module_name == "ntdll.dll" {
			ntdll_found = true
			fmt.Println("ntdll_found : ", current_module_name)

		}
	}

	// get module base
	ntdll_base = uintptr(unsafe.Pointer(currentModuleList.DllBase))
	fmt.Printf("ntdll_base : %x\n", ntdll_base)

	// get the VA of the modules NT Header
	ntdll_dos_headers := (*pe.DosHeader)(unsafe.Pointer(ntdll_base))
	ntdll_nt_headers_ptr := ntdll_base + uintptr(ntdll_dos_headers.AddressOfNewExeHeader)

	// nt_headers
	ntdll_nt_headers := (*IMAGE_NT_HEADERS64)(unsafe.Pointer(ntdll_nt_headers_ptr))

	// optional headers
	ntdll_optional_headers := (*pe.OptionalHeader64)(unsafe.Pointer(&ntdll_nt_headers.IMAGE_OPTIONAL_HEADER64))

	// export directory
	IMAGE_DIRECTORY_ENTRY_EXPORT := 0
	ntdll_export_directory := ntdll_optional_headers.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT]

	// get the VA of the export directory
	ntdll_export_directory_va := ntdll_base + uintptr(ntdll_export_directory.VirtualAddress)

	// get the VA for the array of name pointers
	ntdll_image_export_directory := (*IMAGE_EXPORT_DIRECTORY)(unsafe.Pointer(ntdll_export_directory_va))
	ntdll_AddressOfNames := ntdll_base + uintptr(ntdll_image_export_directory.AddressOfNames)
	ntdll_AddressOfOrdinals := ntdll_base + uintptr(ntdll_image_export_directory.AddressOfNameOrdinals)
	fmt.Printf("ntdll_AddressOfNames : %x\n", ntdll_AddressOfNames)
	fmt.Printf("ntdll_AddressOfOrdinals: %x\n", ntdll_AddressOfOrdinals)

	continue_v := true
	for continue_v {
		ntdll_AddressOfNames_dereferenced := *(*uint32)(unsafe.Pointer(ntdll_AddressOfNames))

		ntdll_function_name_ptr := ntdll_base + uintptr(ntdll_AddressOfNames_dereferenced)
		//fmt.Printf("ntdll_AddressOfNames_dereferenced : %x\n", ntdll_function_name_ptr)
		ntdll_function_name, err := GrabStringFromPtr(ntdll_function_name_ptr)
		if err != nil {
			fmt.Println("Error while GrabStringFromPtr")
		}
		//fmt.Printf("ntdll_AddressOfNames_dereferenced : %v\n", ntdll_function_name)

		//time.Sleep(1000 * time.Second)

		//NtSetEventBoostPriority
		if ntdll_function_name == "NtSetEventBoostPriority" {
			fmt.Printf("found reference function : %v\n", ntdll_function_name)
			continue_v = false

			// get the VA for the array of addresses
			AddressOfFunctions_VA := ntdll_base + uintptr(ntdll_image_export_directory.AddressOfFunctions)
			fmt.Printf("AddressOfFunctions_VA : %x\n", AddressOfFunctions_VA)
			fmt.Printf("AddressOfFunctions_VA deref : %x\n", *(*uint32)(unsafe.Pointer(AddressOfFunctions_VA)))

			//derefence ordinal
			ordinal_value_dereferenced := *(*uint16)(unsafe.Pointer(ntdll_AddressOfOrdinals))
			fmt.Printf("ordinal_value_dereferenced : %x\n", ordinal_value_dereferenced)

			//use ordinal to get the functions AddressOfFunctions_VA
			AddressOfFunctions_VA += uintptr(uint16(ordinal_value_dereferenced * 4)) // * 4 bytes
			fmt.Printf("AddressOfFunctions_VA : %x\n", AddressOfFunctions_VA)
			AddressOfFunctions_VA_deref := *(*uint32)(unsafe.Pointer(AddressOfFunctions_VA))
			fmt.Printf("AddressOfFunctions_VA deref : %x\n", AddressOfFunctions_VA_deref)

			// get function VA
			function_VA := ntdll_base + uintptr(AddressOfFunctions_VA_deref)
			fmt.Printf("function_VA : %x\n", function_VA)

			// get syscall instruction address
			syscall_VA := function_VA + uintptr(18) //syscall is 18 bytes after
			fmt.Printf("syscall_VA : %x\n", syscall_VA)
			return syscall_VA
			//time.Sleep(1000 * time.Second)

		}
		ntdll_AddressOfNames += 4
		ntdll_AddressOfOrdinals += 2
	}

	// time.Sleep(1000 * time.Second)
	return 0x0
}

type PebLdrData struct {
	Length                          uint32
	Initialized                     byte
	SsHandle                        uintptr
	InLoadOrderModuleList           windows.LIST_ENTRY
	InMemoryOrderModuleList         windows.LIST_ENTRY
	InInitializationOrderModuleList windows.LIST_ENTRY
	EntryInProgress                 unsafe.Pointer
	ShutdownInProgress              byte
	ShutdownThreadId                uintptr
}

type LdrDataTableEntry struct { //from https://pkg.go.dev/github.com/byronzhu-haha/BananaPhone/pkg/BananaPhone
	InLoadOrderLinks           windows.LIST_ENTRY
	InMemoryOrderLinks         windows.LIST_ENTRY
	InInitializationOrderLinks windows.LIST_ENTRY
	DllBase                    *uintptr
	EntryPoint                 *uintptr
	SizeOfImage                *uintptr
	FullDllName                windows.NTUnicodeString
	BaseDllName                windows.NTUnicodeString
	Flags                      uint32
	LoadCount                  uint16
	TlsIndex                   uint16
	HashLinks                  windows.LIST_ENTRY
	TimeDateStamp              uint64
}

type IMAGE_NT_HEADERS64 struct {
	Signature               uint32
	IMAGE_FILE_HEADER       pe.FileHeader
	IMAGE_OPTIONAL_HEADER64 pe.OptionalHeader64
}

type IMAGE_EXPORT_DIRECTORY struct { //from https://github.com/golang/go/blob/841e63e480ca2626e0cd0bbf8df31f8c6d8ee597/src/cmd/link/internal/ld/pe.go#L32
	Characteristics       uint32
	TimeDateStamp         uint32
	MajorVersion          uint16
	MinorVersion          uint16
	Name                  uint32
	Base                  uint32
	NumberOfFunctions     uint32
	NumberOfNames         uint32
	AddressOfFunctions    uint32
	AddressOfNames        uint32
	AddressOfNameOrdinals uint32
}

func GrabStringFromPtrUTF16(ptr uintptr, length uint16) (string, error) {
	extracted_string := make([]byte, 2)
	char := *(*byte)(unsafe.Pointer(ptr))
	counter := uint16(0)
	//fmt.Println("next_char :", next_char)
	for counter != length {
		char = *(*byte)(unsafe.Pointer(ptr + uintptr(counter)))
		if counter%2 == 0 { // UTF16 so we take 1/2 char
			extracted_string = append(extracted_string, char)
		}
		counter++
	}
	return string(extracted_string[2:]), nil // two first bytes are null, so we remove them
}

func GrabStringFromPtr(ptr uintptr) (string, error) {
	extracted_string := make([]byte, 2)
	char := *(*byte)(unsafe.Pointer(ptr))
	next_char := *(*byte)(unsafe.Pointer(ptr)) // Dirty way to stop just before getting the null byte of the end
	index := 0
	for next_char != 0 {
		char = *(*byte)(unsafe.Pointer(ptr + uintptr(index)))
		extracted_string = append(extracted_string, char)
		index++
		next_char = *(*byte)(unsafe.Pointer(ptr + uintptr(index)))
	}
	return string(extracted_string[2:]), nil // two first bytes are null, so we remove them
}
